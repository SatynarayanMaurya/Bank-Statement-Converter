const fs = require('fs');
const pdfParse = require('pdf-parse');

exports.HdfcBankController = async (req, res) => {
  try {
    const file = req.files?.pdfInput;
    if (!file) return res.status(400).json({ error: "No PDF uploaded." });

    const dataBuffer = fs.readFileSync(file.tempFilePath);
    const parsed = await pdfParse(dataBuffer);
    const lines = parsed.text.split('\n').map(line => line.trim()).filter(Boolean);

    const transactions = [];
    const groupedLines = [];

    let currentGroup = [];

    const transactionStartRegex = /^(\d{2}\/\d{2}\/\d{2})/;

    // Group lines by transaction
    for (const line of lines) {
      const isNewTransaction = transactionStartRegex.test(line);

      if (isNewTransaction) {
        if (currentGroup.length > 0) groupedLines.push(currentGroup);
        currentGroup = [line];
      } else if (currentGroup.length > 0) {
        currentGroup.push(line);
      }
    }

    if (currentGroup.length > 0) groupedLines.push(currentGroup);

    // Keywords to filter out extra metadata lines
const isMetadataLine = (line) => {
  const l = line.toLowerCase();
  return (
    l.startsWith("page no") ||
    l.includes("statement of account") ||
    l.includes("joint holders") ||
    l.includes("nomination") ||
    l.includes("account branch") ||
    l.includes("generated on") ||
    l.includes("generated by") ||
    l.includes("rtgs/neft ifsc") ||
    l.includes("product code") ||
    l.includes("currency:") ||
    l.includes("phone no.") ||
    l.includes("email:") ||
    l.includes("cust id:") ||
    l.includes("account no:") ||
    l.includes("a/c open date") ||
    l.includes("account status") ||
    l.includes("gstin") ||
    l.includes("registered office address") ||
    l.includes("this is a computer generated") ||
    l.includes("hdfc bank limited") ||
    l.includes("opening balancedr count") || // your example has this
    /^\*closing balance includes/i.test(l)
  );
};


let prevBalance = null;

for (const group of groupedLines) {
  const cleanGroup = group.filter(line => !isMetadataLine(line));
  if (cleanGroup.length === 0) continue;

  const fullText = cleanGroup.join(' ').replace(/\s+/g, ' ').trim();

  // Step 1: Extract initial date
  const dateMatch = fullText.match(/^(\d{2}\/\d{2}\/\d{2})/);
  if (!dateMatch) continue;
  const date = dateMatch[1];
  let rest = fullText.replace(date, '').trim();
//   console.log("Rest : ",rest)

  // Step 2: Find valueDate within rest (second date)
  const valueDateMatch = rest.match(/(\d{2}\/\d{2}\/\d{2})/);
//   console.log('value date match : ',valueDateMatch)
  if (!valueDateMatch) continue;
  const valueDate = valueDateMatch[1];
  const valueDateIndex = rest.indexOf(valueDate);

  // Step 3: Extract refNo → 16 characters before valueDate
  const refNoStart = Math.max(0, valueDateIndex - 16);
  const refNo = rest.slice(refNoStart, valueDateIndex).trim();

  // Step 4: Extract narration
  const narration = rest.slice(0, refNoStart).trim();

  // Step 5: Trim rest after valueDate (now ready for amount/balance)
  rest = rest.slice(valueDateIndex + valueDate.length).trim();

  // Step 6: Extract amount and balance at the end
const amtBalRegex = /(\d{1,3}(?:,\d{3})*\.\d{2})(?=\d{1,3}(?:,\d{3})*\.\d{2})|(\d{1,3}(?:,\d{3})*\.\d{2})/g;
const amtMatch = rest.match(amtBalRegex);
if (!amtMatch || amtMatch.length < 2) continue;

const amount = parseFloat(amtMatch[0].replace(/,/g, ""));
const balance = parseFloat(amtMatch[1].replace(/,/g, ""));

// Step 7: Determine type
let deposit = null;
let withdrawal = null;
let type = "debit";

if (prevBalance !== null) {
  type = balance > prevBalance ? "credit" : "debit";
}

if (type === "credit") {
  deposit = amount;
} else {
  withdrawal = amount;
}

prevBalance = balance;

// Push final transaction
transactions.push({
  date,
  valueDate,
  narration,
  refNo,
  deposit,
  withdrawal,
  balance
});

}



    return res.status(200).json({ data: transactions });
  } catch (error) {
    console.error("❌ Error parsing PDF:", error);
    return res.status(500).json({ error: error?.message });
  }
};
